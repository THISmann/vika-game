---
# Logstash pour traiter et enrichir les logs
apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash-config
  namespace: elk
data:
  logstash.yml: |
    http.host: "0.0.0.0"
    xpack.monitoring.elasticsearch.hosts: ["http://elasticsearch:9200"]
  pipelines.yml: |
    - pipeline.id: main
      path.config: "/usr/share/logstash/pipeline/logstash.conf"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash-pipeline
  namespace: elk
data:
  logstash.conf: |
    input {
      beats {
        port => 5044
      }
    }

    filter {
      # Parser les logs JSON si disponibles
      if [message] =~ /^\{/ {
        json {
          source => "message"
        }
      }

      # Extraire les informations des logs Kubernetes
      if [kubernetes] {
        mutate {
          add_field => {
            "namespace" => "%{[kubernetes][namespace]}"
            "pod_name" => "%{[kubernetes][pod][name]}"
            "container_name" => "%{[kubernetes][container][name]}"
          }
        }
      }

      # Parser les logs des endpoints critiques
      # Format: [timestamp] [level] [endpoint] [method] [status] [message]
      
      # Logs des endpoints Game Service
      if [container_name] == "game-service" {
        grok {
          match => {
            "message" => [
              "POST /game/answer.*%{NUMBER:http_status:int}",
              "GET /game/score.*%{NUMBER:http_status:int}",
              "GET /game/leaderboard.*%{NUMBER:http_status:int}",
              "POST /game/start.*%{NUMBER:http_status:int}",
              "POST /game/next.*%{NUMBER:http_status:int}",
              "POST /game/end.*%{NUMBER:http_status:int}",
              "GET /game/results.*%{NUMBER:http_status:int}"
            ]
          }
        }
        
        # Extraire les informations des réponses
        if [message] =~ /ANSWER QUESTION/ {
          grok {
            match => {
              "message" => "Player: %{DATA:player_name} \(%{DATA:player_id}\)"
            }
          }
          grok {
            match => {
              "message" => "Question ID: %{DATA:question_id}"
            }
          }
          grok {
            match => {
              "message" => "Is correct: %{WORD:is_correct}"
            }
          }
          mutate {
            add_field => { "endpoint_type" => "answer" }
            add_field => { "critical_endpoint" => "true" }
          }
        }
        
        # Extraire les informations de démarrage de jeu
        if [message] =~ /GAME STARTED/ {
          mutate {
            add_field => { "endpoint_type" => "start_game" }
            add_field => { "critical_endpoint" => "true" }
          }
        }
        
        # Extraire les erreurs
        if [message] =~ /(?i)(error|❌|failed|exception)/ {
          mutate {
            add_field => { "log_level" => "error" }
            add_field => { "critical_endpoint" => "true" }
          }
        }
      }

      # Logs des endpoints Auth Service
      if [container_name] == "auth-service" {
        grok {
          match => {
            "message" => [
              "POST /auth/admin/login.*%{NUMBER:http_status:int}",
              "POST /auth/players/register.*%{NUMBER:http_status:int}",
              "GET /auth/players.*%{NUMBER:http_status:int}"
            ]
          }
        }
        
        if [message] =~ /(?i)(login|register|authentication)/ {
          mutate {
            add_field => { "endpoint_type" => "auth" }
            add_field => { "critical_endpoint" => "true" }
          }
        }
      }

      # Logs des endpoints Quiz Service
      if [container_name] == "quiz-service" {
        grok {
          match => {
            "message" => [
              "GET /quiz/all.*%{NUMBER:http_status:int}",
              "GET /quiz/full.*%{NUMBER:http_status:int}",
              "POST /quiz/create.*%{NUMBER:http_status:int}",
              "GET /quiz/verify/%{DATA:question_id}.*%{NUMBER:http_status:int}"
            ]
          }
        }
        
        if [message] =~ /(?i)(question|quiz|verify)/ {
          mutate {
            add_field => { "endpoint_type" => "quiz" }
            add_field => { "critical_endpoint" => "true" }
          }
        }
      }

      # Parser les logs WebSocket
      if [message] =~ /(?i)(websocket|socket\.io|register|connected|disconnected)/ {
        grok {
          match => {
            "message" => [
              "Socket ID: %{DATA:socket_id}",
              "Player ID: %{DATA:player_id}",
              "Connected: %{WORD:connected_status}",
              "Event: %{DATA:event_name}"
            ]
          }
        }
        mutate {
          add_field => { "endpoint_type" => "websocket" }
          add_field => { "critical_endpoint" => "true" }
        }
      }

      # Parser les logs de performance
      if [message] =~ /(?i)(duration|response time|latency|ms|seconds)/ {
        grok {
          match => {
            "message" => [
              "Duration: %{NUMBER:duration:float}%{WORD:duration_unit}",
              "Response time: %{NUMBER:response_time:float}ms",
              "Latency: %{NUMBER:latency:float}ms"
            ]
          }
        }
        mutate {
          add_field => { "has_performance_metric" => "true" }
        }
      }

      # Ajouter un timestamp si absent
      if ![timestamp] {
        date {
          match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss" ]
          target => "@timestamp"
        }
      }

      # Normaliser les niveaux de log
      if [log_level] {
        mutate {
          lowercase => [ "log_level" ]
        }
      } else {
        if [message] =~ /(?i)(error|❌|failed|exception)/ {
          mutate {
            add_field => { "log_level" => "error" }
          }
        } else if [message] =~ /(?i)(warn|warning|⚠)/ {
          mutate {
            add_field => { "log_level" => "warn" }
          }
        } else if [message] =~ /(?i)(info|✅|success)/ {
          mutate {
            add_field => { "log_level" => "info" }
          }
        } else {
          mutate {
            add_field => { "log_level" => "debug" }
          }
        }
      }

      # Ajouter des tags pour faciliter les recherches
      if [critical_endpoint] == "true" {
        mutate {
          add_tag => [ "critical", "endpoint" ]
        }
      }

      if [log_level] == "error" {
        mutate {
          add_tag => [ "error", "alert" ]
        }
      }
    }

    output {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "gamev2-logs-%{+YYYY.MM.dd}"
        template_name => "gamev2-logs"
        template => "/usr/share/logstash/templates/gamev2-template.json"
        template_overwrite => true
      }
      
      # Logs d'erreur dans un index séparé
      if [log_level] == "error" {
        elasticsearch {
          hosts => ["http://elasticsearch:9200"]
          index => "gamev2-errors-%{+YYYY.MM.dd}"
        }
      }
      
      # Logs des endpoints critiques dans un index séparé
      if [critical_endpoint] == "true" {
        elasticsearch {
          hosts => ["http://elasticsearch:9200"]
          index => "gamev2-critical-%{+YYYY.MM.dd}"
        }
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: logstash
  namespace: elk
  labels:
    app: logstash
spec:
  replicas: 1
  selector:
    matchLabels:
      app: logstash
  template:
    metadata:
      labels:
        app: logstash
    spec:
      containers:
      - name: logstash
        image: docker.elastic.co/logstash/logstash:8.11.0
        ports:
        - containerPort: 5044
          name: beats
        env:
        - name: LS_JAVA_OPTS
          value: "-Xmx1g -Xms1g"
        volumeMounts:
        - name: config
          mountPath: /usr/share/logstash/config/logstash.yml
          subPath: logstash.yml
        - name: pipeline
          mountPath: /usr/share/logstash/pipeline/logstash.conf
          subPath: logstash.conf
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
      volumes:
      - name: config
        configMap:
          name: logstash-config
      - name: pipeline
        configMap:
          name: logstash-pipeline
---
apiVersion: v1
kind: Service
metadata:
  name: logstash
  namespace: elk
  labels:
    app: logstash
spec:
  type: ClusterIP
  ports:
  - port: 5044
    targetPort: 5044
    name: beats
  selector:
    app: logstash

